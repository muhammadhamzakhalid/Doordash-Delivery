"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DoorDashClient = void 0;
const jwt_1 = require("../utils/jwt");
const error_1 = require("../error/error");
const error_2 = require("../error/error");
const api_1 = require("../generated-client/api");
class DoorDashClient {
    constructor(tokenContext) {
        if (!tokenContext.key_id || !tokenContext.developer_id || !tokenContext.signing_secret) {
            throw new error_1.DoorDashAuthenticationError("missing_auth_field", "Missing fields in token context. Please provide keyId, developerId and signingSecret");
        }
        this._tokenContext = tokenContext;
        this._apiClient = new api_1.RequestDasherApi();
    }
    /**
     * Cancel delivery
     * @summary Cancel Delivery
     * @param {string} externalDeliveryId Unique (per developer) ID of the delivery.
     * @param {*} [options] Override http request option.
     * @throws {DoorDashError}
     */
    cancelDelivery(externalDeliveryId, options) {
        return this._wrap(this._apiClient.cancelDelivery(externalDeliveryId, this._generateOptions(options)));
    }
    /**
     * Create a delivery
     * @summary Create Delivery
     * @param {CreateDeliveryInput} createDeliveryInput
     * @param {*} [options] Override http request option.
     * @throws {DoorDashError}
     */
    createDelivery(createDeliveryInput, options) {
        return this._wrap(this._apiClient.createDelivery(createDeliveryInput, this._generateOptions(options)));
    }
    /**
     * Get a quote on delivery fee and validate coverage.
     * @summary Delivery Quote
     * @param {DeliveryQuoteInput} deliveryQuoteInput
     * @param {*} [options] Override http request option.
     * @throws {DoorDashError}
     */
    deliveryQuote(deliveryQuoteInput, options) {
        return this._wrap(this._apiClient.deliveryQuote(deliveryQuoteInput, this._generateOptions(options)));
    }
    /**
     * Accept Delivery Quote
     * @summary Accept Delivery Quote
     * @param {string} externalDeliveryId Unique (per developer) ID of the delivery.
     * @param {*} [options] Override http request option.
     * @throws {DoorDashError}
     */
    deliveryQuoteAccept(externalDeliveryId, options) {
        return this._wrap(this._apiClient.deliveryQuoteAccept(externalDeliveryId, this._generateOptions(options)));
    }
    /**
     * Get delivery status and details
     * @summary Get Delivery Status
     * @param {string} externalDeliveryId Unique (per developer) ID of the delivery.
     * @param {*} [options] Override http request option.
     * @throws {DoorDashError}
     */
    getDelivery(externalDeliveryId, options) {
        return this._wrap(this._apiClient.getDelivery(externalDeliveryId, this._generateOptions(options)));
    }
    /**
     * Update the time or address for a delivery
     * @summary Update Delivery
     * @param {string} externalDeliveryId Unique (per developer) ID of the delivery.
     * @param {UpdateDeliveryInput} updateDeliveryInput
     * @param {*} [options] Override http request option.
     * @throws {DoorDashError}
     */
    updateDelivery(externalDeliveryId, updateDeliveryInput, options) {
        return this._wrap(this._apiClient.updateDelivery(externalDeliveryId, updateDeliveryInput, this._generateOptions(options)));
    }
    _wrap(axiosResponse) {
        return axiosResponse.then((response) => {
            return {
                data: response.data,
                status: response.status,
                message: response.statusText
            };
        }).catch((error) => {
            const status = error.response.status;
            const errorCode = error && error.response && error.response.data ? error.response.data.code : null;
            const message = error && error.response && error.response.data ? error.response.data.message : null;
            const fieldErrors = error && error.response && error.response.data ? error.response.data.field_errors : null;
            if (status === 401) {
                throw new error_2.DoorDashAuthorizationError("Unauthorized", message);
            }
            else if (status === 429) {
                throw new error_1.DoorDashThrottledError("Throttled", message);
            }
            else {
                throw error_1.DoorDashError.mapCodeToError(errorCode, message, fieldErrors);
            }
        });
    }
    _generateOptions(options) {
        const jwt = jwt_1.Jwt.generateJwt(this._tokenContext);
        return { headers: { "Authorization": "Bearer " + jwt }, ...options };
    }
}
exports.DoorDashClient = DoorDashClient;
//# sourceMappingURL=doordash-client.js.map